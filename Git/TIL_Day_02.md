> 2022년 5월 20일 금요일

# Github


### 원격 저장소(Remote Repository)
> Github의 원격 저장소를 이용해 로컬 저장소에서의 버전 관리를 다른 사람과 공유할 수 있음 (협업)

1. Github에서 new repository를 통해 원격 저장소 생성
   - 저장소의 이름, 설명, 공개 여부 선택
2. 로컬 저장소와 원격 저장소 연결 **(remote)**

``` 
// 이미 .git으로 관리되고 있는 디렉토리에는 하지 않아도 됨
$ git init

// new repository 생성 후 github에 생긴 저장소 주소를 입력
// add 할 때 저장소주소 앞에 저장소의 이름을 입력 일반적으로 origin을 사용함
$ git remote add origin(저장소별명) 저장소주소

// 원격 저장소의 이름과 주소 조회
$ git romote -v
```

3. 버전 관리된 커밋 업로드 **(push)**

```
// 상태 확인 하기 위해 git status로 확인도 중간에 하기

$ git add . // staging area
$ git commit -m "내용" // git directory

// 커밋된 버전을 연결된 원격 저장소로 업로드
//origin은 원격 저장소와 연결 할 때 지정한 저장주소의 이름(별명)
//master는 브랜치 이름
$ git push origin master

// -u 옵션을 사용하면 두번째 커밋 부터는 저장소 이름과 브랜치 이름 생략가능
$ git push -u origin master
```

4. 원격 저장소(Github)에서 정상 업로드 확인

5. 만약 원격 저장소와 로컬 저장소의 연결을 끊고 싶다면?
   - 원격 저장소 자체를 삭제하는 것은 아님

```
// 둘 중에 하나 사용
$ git remote rm origin
$ git remote remove origin

// remote(원격 저장소)와의 연결을 rm(remove)한다.
// 그 원격 저장소의 주소 이름은 origin
```



-------



# .gitignore

> 특정 파일 혹은 폴더에 대해 Git이 버전관리를 하지 못하도록 지정

- 사용하는 **이유**
  - 공개하면 안되는 내용이나  불필요한 소스들을 업로드 하지 않기 위해
- 작성시 **주의 사항**
  - 반드시 이름을 **.gitignore** 로 작성(.은 숨김파일이라는 뜻)
  - 제외 하고 싶은 파일은 **반드시, git add 하기 전에** .gitignore에 작성
  - 이유는 git add 후는 이미 staging area 에 존재하게 되기 때문에 .git에 tracked 상태(버전관리 대상)가 되기 때문이다.
  - 따라서 프로젝트 생성 할 때 만들어주면 좋음
- gitignore **작성목록**
  1. 민감한 개인정보가 담긴 파일(전화번호, 계좌번호, 주민번호, 비밀번호 , API key 등)
  2. OS에서 활용되는 파일
  3. IDE혹은 Text deitor 등에서 활용되는 파일
  4. 개발언어, 프레임워크에서 사용되는 파일

### 개발환경에 맞춘 .gitignore 쉽게 작성하기

- [웹사이트](https://www.toptal.com/developers/gitignore/)
  - 사용하는 운영체제, 개발언어, 에디터 등을 검색하여 적용 할 수 있음
  - 전체 복사, 붙여넣기 하면됨
- [gitignore 저장소](https://github.com/github/gitignore)

### .gitignore 패턴 규칙

1. 아무것도 없는 라인과 **#** 으로 시작하는 라인은 아무 적용 안됨

2.  **슬래시(/) 로 시작**하면 하위 디렉터리에 재귀적으로 적용되지 않음

3. **슬래시(/)** 를 끝에 사용함으로 디렉토리를 표현함

4. **느낌표(!)** 로 시작하는 패턴의 파일은 (ignore)무시하지 않음 무시되는 파일 중 무시하고 싶지 않은 특정 파일을 지정할 때 사용

5. Glob 패턴 사용

   > Glob 패턴은 와일드카드 문자를 사용해서 일정한 패턴을 가진 파일 이름들을 지정하기 위한 패턴임

   - *(asterisk) 는 **문자가 하나도 없거나 하나 이상**을 의미

     `*.txt` // 확장자가 txt인 파일 무시

   - [abc]는 중괄호 안에 있는 문자 중 하나 의미

   - 물음표(?)는 **문자 하나**를 의미

     `?.txt` // 확장자가 txt인 파일 중 a.txt처럼 문자가 하나인 것 무시

   - [0-9]처럼 중괄호 안에 하이픈이 있는 경우 0에서 사이의 문자 중 하나를 의미함

   - **(2개의 asterisk)는 디렉토리 _내부의 디렉토리까지 지정_  가능

     (a/**/z 라고 작성하면 a/z, a/b/z, a/b/c/z까지 모두 영향을 줌)

   - 예시

   ```
   # 현재 디렉토리에 있는 Test파일은 무시하고
   # workspace/Test 처럼 하위 디렉토리에 있는 Test파일은 무시하지 않음(재귀적 적용 x)
   /Test
   
   # workspace/ 디렉터리에 있는 모든 파일 무시
   workspace/
   
   # folder/note1.txt 파일은 무시하고
   # folder/child/note2.txt 파일은 무시하지 않음(재귀적 적용 x)
   folder/*.txt
   
   # folder 디렉토리 아래의 모든 .pdf 파일을 무시
   folder/**/*.pdf
   ```



------



# clone, pull

- clone: 원격 저장소를 복제하여 로컬저장소 생성

  ```
  $ git clone 원격저장소주소
  ```

  

- pull: 원격 저장소에서 업데이트된 버전을 가지고 옴

  ```
  $ git pull origin master
  ```

  

###  clone/push/pull 협업시 주의 사항

- 동시에 수정하고 commit / push한 경우 일어날 수 있는 3가지 상황
  1. 서로 다른 파일을 수정한 경우 :  정상적으로 git pull
  2.  서로 같은 파일이지만 다른 라인을 수정한 경우 :  정상적으로 git pull
  3. 같은 파일의 같은 라인을 수정한 경우 : 충돌(conflict) 발생 
     - 이 경우 원격 저장소의 내용을 받아와 상대방이 변경한 최신의 상태가 아닌 로컬저장소에서 같은 부분을 커밋을 했기 때문이다
     -  한 쪽에서 `git pull origin master` 해서 원격저장소의 최신상태로  동기화 시킨 후, 겹치는 라인의 내용을  직접 선택하고 `git add .` `git commit -m "내용"` 해서 push 함



------



# branch

> 버전 관리의 꽃 branch

- branch 영어 뜻처럼 여러 갈래로 나눠져 작업 공간을 독립적으로 작업 할 수 있도록 도와주는 Git의 도구임

- **장점**

  1. 독립 공간을 형성하기 때문에 원본(master)에 대해 안전
  2. 하나의 작업은 하나의 브랜치로 나누어 진행되므로 체계적인 개발이 가능해짐
  3. 특히 Git은 브랜치를 만드는 속도가 굉장히 빠르고 용량도 적게듬

- **사용이유**

  - 어떤 서비스를 운영하고 개발 할 때 업데이트 및 에러 해결해야 하는 상황이 생기는데 고객이 사용중인 버전을 되돌리거나 삭제 할 수 없음
  - master 브랜치는 상용을 의미하는데, 다른 브랜치를 만들어 독립적인 공간에서 업데이트 및 에러 수정을 할 수 있기 때문에 master에 영향을 끼치지 않게됨
  - 다른 브랜치에서 작업이 끝난 후 그 내용 반영 가능함

- **branch  생성/ 조회 /삭제**

  > 브랜치 생성 시 특정 커밋을 지정하지 않으면, 새로운 브랜치는 생성한 시점의 커밋버전임

  ```
  // branch 생성
  $ git branch 브랜치이름
  
  // 특정 커밋 기준으로 브랜치 생성
  $ git branch 브랜치이름 커밋ID
  
  // branch 브랜치 목록 확인(조회)
  // 목록 결과에 나오는 브랜치 이름 앞에 * 의 의미는 현재 HEAD가 가리키는 브랜치
  $ git branch
  
  // 원격 저장소의 브랜치 목록 확인
  $ git branch -r
  
  // 특정 브랜치 삭제
  $ git branch -d 브랜치이름 // 병합된 브랜치만 삭제 
  $ git branch -D 브랜치이름 // 주의! 강제 삭제(병합되지 않은 브랜치도 삭제 가능)
  ```

- **git switch**

  > 현재 브랜치에서 다른 브랜치로 **HEAD**를 이동시키는 명령어 
  >
  > **HEAD**란 현재 브랜치의 최신 커밋을 가리키는 포인터를 의미함

  ```
  // 다른 브랜치로 이동
  $ git switch 다른브랜치이름
  
  // 브랜치 생성과 동시에 이동
  $ git switch -c 브랜치이름
  
  // 특정 커밋 기준으로 브랜치 생성과 이동
  $ git switch -c 브랜치이름 커밋ID
  ```

  - 주의사항!
    - 브랜치 이동전에 해당 브랜치의 **변경사항 꼭 커밋**하기
    - 커밋하지 않으면 변경내용이 반영되지 않음



### git log --옵션

> 커밋 및 브랜치 로그(상태 파악 가능)

```
// 현재 브랜치에 반영된 커밋 히스토리만 보여줌
$ git log --oneline

// 현재 브랜치 뿐만 아니라 다른 브랜치의 커밋 히스토리를 다 보여줌 
$ git log --oneline --all

// 모든 브랜치의 커밋 히스토리 그래프로 보여줌
$ git log --oneline --graph --all
```

#### + VScode extension을 통해 git graph를 install해서 볼 수도 있음



--------



# branch merge

> 브랜치 병합
>
> 브랜치를 생성함으로써 독립적으로 나눠진 공간의 최신 상태를 master(상용)브랜치에 반영 하기 위해 사용

- git merge
  - merge하기 전에 최신 브랜치를 합치는 대상, 즉 메인 브랜치로 switch 해아함

```
$ git switch master
$ git merge 합칠브랜치이름
```

- merge의 3가지 상황 
  1.  **Fast - Forward (빨리감기)**
     - 나눠진 브랜치가 아닌 이전 브랜치와 최신 브랜치의 병합(최신 version으로 update)
  2.  **3-way Merge**
     - 서로 다른 부분(다른 파일 또는 같은파일의 다른 부분)을 수정한 각 브랜치의 병합
     - 병합되면서 새로운 커밋(merge commit)이 생김
  3.  **Merge Conflict**
     - 병합하는 두 브랜치에서 같은 파일의 같은 부분을 수정한 경우, Git이 어느 브랜치의 내용으로 작성해야 하는지 판단하지 못해서 **충돌** 발생
     - 사용자가 직접 내용을 선택해서 Conflict 해결
     - `git status` 로 충돌이 일어난 파일 확인
     - 같은 부분이 있는 파일을 열어보면 **========** 를 기준으로 나눠져 있는 충돌이 발생한 내용을 확인함
     - 충돌이 발생한 내용 중 하나만 선택할 수도 있고, 다 선택 할 수도 있고, 새롭게 작성할 수도 있음
     - 선택 이후 `git add` 와 `git commit` 을 통해 병합한 내용을 커밋함
     - vim 편집기를 이용해 커밋내용 수정가능 (esc를 누른 후 :wq를 입력하여 저장& 종료)



#### +기능을 다 하고 merge된 브랜치는 삭제하기

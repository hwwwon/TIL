## 인터페이스 (Interface)

- 객체의 사용 방법을 정의한 타입
- 클래스들이 구현해야하는 동작을 지정하는데 사용되는 추상형
- 미리 정해진 규칙에 맞게 구현하도록 표준을 제시하기 위해 사용
- 인터페이스 간 상속 가능
- 다중 상속 가능
- 역할
  - 개발코드와 객체가 서로 통신하는 접점
  - 개발 코드가 인터페이스의 메소드를 호출하면, 인터페이스는 객체의 메소드 호출
  - 중간에 인터페이스를 사용하는 이유는 개발 코드를 수정하지 않고 시용하는 객체를 변경하기 위함(다형성)
- 특징
  - 구현되지 않은 추상 메소드를 포함하고 있기 때문에 객체 생성할 수 없음
  - 생성자 x
  - 인터페이스 간의 상속 가능
  - 인터페이스를 상속받아 클래스를 구현하면 인터페이스의 모든 추상 메소드를 구현해야 함
- 작성 과정
  1. 선언 : **interface** 키워드로 선언
  2. 구현 : class에서 인터페이스 구현, **implements** 키워드로 명시 (구현 클래스)
  3. 사용 :  구현된 클래스(오버라이딩)의 객체 대입
     - 예) 인터페이스: RemoteControl / 구현 클래스: Television
     - RemoteControl rc = new Television();



### 인터페이스 구성 멤버

> 상수필드, 추상 메소드, 디폴트 메소드, private 메소드, static 메소드

#### 1. 상수필드

> **[public static final] 타입 상수명 = 값;**  [] 생략가능

- 인터페이스는 런타임 시 데이터를 저장할 수 있는 필드를 선언할 수 없지만
- 상수 필드는 선언 가능(데이터 변경 불가)
- **선언과 동시에 초기값 지정**
- 상수명은 **대문자, _로** 연결하여 작성



#### 2. 추상 메소드 (abstaract) ★

> **[public abstract] 리턴타입 메소드명(매개변수,...);**

- 선언은 되어있으나 body가 정의되어 있지 않은 메소드 **({}중괄호 없음)**
- 객체가 가지고 있는 메소드를 설명한 것으로 **메소드명, 매개변수, 리턴타입만 기술**
- 실제 실행 내용은 구현 객체에 작성(실체 클래스에서 오버라이딩)
- **인터페이스 메소드는 기본적으로 실행 블록이 없는 추상메소드로 선언**
- 접근제한자 **public** 사용
- **public abstract 생략가능**



#### 3. 디폴드 메소드 (default)

> **[public] default 리턴타입 메소드명(매개변수,...){ ... }**

- **실행 블록({ })을 가지고 있는 메소드**
- **default 키워드를** 반드시 붙여야 함
- 이유: default 키워드를 생략하게 되면 추상메소드와 같아짐
- 접근제한자 **public** 사용
- 인터페이스에 선언되지만 사실은 **구현 객체가 가지고 있는 인스턴스 메소드**
- 기존 인터페이스를 확장해서 새로운 기능을 추가하기 이해 Java8부터 적용
- 기존의 인터페이스를 확장하면서 추상 메소드를 추가하면 기존의 인터페이스를 사용하던 구현 클래스에 오류가 발생하기 때문에
- 꼭 재정의 하지 않아도 새로운 기능을 선택적으로 추가 가능하면서 새로운 기능을 사용할 수 있도록 하기 위함
- 디폴트 메소드를 가진 인터페이스 상속
  - Case1 : 디폴트 메소드를 단순히 상속만 받음
  - Case2 : 디폴트 메소드를 상속받는 인터페이스에서 재정의해서 실행 내용을 변경
  - Case3 : 디폴트 메소드를 구현 클래스 또는 익명구현객체를 통해 추상 메소드로 재정의




#### 4. 정적 메소드 (static method)

> **[public] static 리턴타입 메소드명(매개변수,...){ ... }**

- **실행 블록({ })을 가지고 있는 메소드**

- 접근제한자 **public** 사용

- 디폴트 메소드와 달리, **객체 없이도** 인터페이스 만을 호출가능한 메소드



#### 5. private 메소드

- 인터페이스 내에서만 사용가능한 메소드
- 디폴트나 정적메소드 내에서 사용하기 위해 작성됨
- 인터페이스를 구현하는 클래스에서 재정의 하거나 사용할 수 없음



-------



## 다중 인터페이스

> 다수의 인터페이스 타입을 사용
>
> 구현 클래스는 모든 인터페이스 추상 메소드에 대해 실체 메소드(오버라이딩)를 작성해야함

```java
public class 구현클래스명 implements 인터페이스A, 인터페이스B{
    //인터페이스A에 선언된 추상 메소드의 실체 메소드 선언
    //인터페이스B에 선언된 추상 메소드의 실체 메소드 선언
}
```

- 하나의 구현 클래스에 다양한 메소드 재정의 가능



-----



## 인터페이스 상속

> 인터페이스 간 상속
>
> 다중 상속 가능

- public interface 하위인터페이스 extends 상위 인터페이스1, 상위 인터페이스2,...{...}
- 하위 인터페이스를 **구현한 클래스**는 아래 추상 메소드를 모두 재정의 해야 함(모든 인터페이스의 추상 메소드 재정의)

### 인터페이스 자동타입변환

- 구현 클래스로부터 객체 생성 후, 하위 및 상위 인터페이스 타입으로 변환 가능
- 하위 인터페이스로 타입변환되는 경우
  - 상-하위 인터페이스에 선언된 모든 메소드 사용 가능
- 상위 인터페이스로 타입변환되는 경우
  - 상위 인터페이스에 선언된 메소드만 사용가능 하고
  - 하위 인터페이스에 선언된 메소드는 사용 불가

``` java
/*
인터페이스에 각 추상메소드를 하나씩 가지고 있는 상태
InterfaceA(methodA()), InterfaceB(methodB()), InterfaceC(methodC())
InterfaceC는 A와 B를 상속받음
InterfaceC 재정의한 구현 클래스 ImplementaionC는 A와B의 추상메소드도 재정의
*/ 
public class InterfaceMain {

	public static void main(String[] args) {
		
		ImplementaionC impl = new ImplementaionC();
		
		InterfaceA ia = impl;
		ia.methodA(); //methodA()만 호출가능
		System.out.println();
		
		InterfaceB ib = impl;
		ib.methodB(); //methodB()만 호출가능
		System.out.println();
		
		InterfaceC ic = impl;
		ic.methodA(); //methodA(),methodB(),methodC() 호출가능
		ic.methodB();
		ic.methodC();
	}

}

```

